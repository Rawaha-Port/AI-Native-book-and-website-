# باب 6: سیمولیشن، پلیٹ فارمز اور کیس اسٹڈیز

## 6.1 تعارف
پچھلے ابواب میں، ہم نے اس نظریے کا احاطہ کیا ہے کہ روبوٹس کیسے بنتے ہیں، وہ کیسے حرکت کرتے ہیں، اور وہ کیسے سوچتے ہیں۔ لیکن روبوٹسٹس اصل میں ان پیچیدہ نظاموں کو کیسے تیار اور جانچتے ہیں؟ سب کچھ ایک حقیقی، مہنگے، اور ممکنہ طور پر نازک روبوٹ پر کرنا اکثر غیر عملی ہوتا ہے۔ یہ باب جدید روبوٹکس کی ترقی میں سیمولیشن کے اہم کردار کا جائزہ لیتا ہے۔ ہم بحث کریں گے کہ سیمولیشن کیوں ناگزیر ہے اور سب سے زیادہ مقبول پلیٹ فارمز کا سروے کریں گے، قابل رسائی PyBullet سے لے کر طاقتور NVIDIA Isaac Sim تک۔ ہم روبوٹ آپریٹنگ سسٹم (ROS) کو بھی متعارف کرائیں گے، جو ماڈیولر روبوٹ سافٹ ویئر بنانے کے لیے ڈی فیکٹو معیاری فریم ورک ہے۔ آخر میں، ہم ان تصورات کو حقیقت میں بنیاد فراہم کریں گے اور دیکھیں گے کہ جدید ہیومنائڈ روبوٹس حقیقی دنیا کے مسائل کو حل کرنے کے لیے کس طرح لاگو کیے جا رہے ہیں۔

## 6.2 نظریاتی بنیادیں

### 6.2.1 سیمولیشن کی اہمیت
سیمولیشن ایک روبوٹ اور اس کے ماحول کا کمپیوٹر ماڈل ہے۔ یہ ڈویلپرز کو اپنے الگورتھم کو ایک مجازی دنیا میں جانچنے کی اجازت دیتا ہے اس سے پہلے کہ وہ انہیں ایک طبعی روبوٹ پر تعینات کریں۔

- **سیمولیٹ کیوں کریں؟**
    - **حفاظت**: نئے کنٹرول یا AI الگورتھم کی جانچ غیر متوقع رویے کا باعث بن سکتی ہے۔ اگر روبوٹ گرتا ہے یا اشیاء سے ٹکراتا ہے تو اسے شدید نقصان پہنچ سکتا ہے (یا نقصان پہنچا سکتا ہے)۔ سیمولیشن تجربات کے لیے ایک محفوظ سینڈ باکس فراہم کرتی ہے۔
    - **رفتار اور متوازیت**: سیمولیشنز اکثر حقیقی وقت سے کہیں زیادہ تیزی سے چل سکتی ہیں۔ مزید برآں، ایک ڈویلپر کلاؤڈ سرور پر ہزاروں سیمولیشنز متوازی طور پر چلا سکتا ہے، جو ڈیٹا کے بھوکے مشین لرننگ تکنیک جیسے کمک سیکھنے کے لیے ضروری ہے۔
    - **لاگت**: طبعی روبوٹس بنانے اور برقرار رکھنے میں مہنگے ہوتے ہیں۔ سیمولیشن طبعی ہارڈ ویئر کی ضرورت کے بغیر ترقی اور جانچ کی اجازت دیتی ہے۔
    - **تکراریت**: حقیقی دنیا کے تجربات ان گنت متغیرات سے متاثر ہو سکتے ہیں۔ سیمولیشن الگورتھم کی ڈیبگنگ اور توثیق کے لیے ایک بالکل کنٹرول شدہ اور قابل تکرار ماحول فراہم کرتی ہے۔

- **"سم-ٹو-ریئل" گیپ**: سیمولیشن میں سب سے بڑا چیلنج یہ ہے کہ ایک سمیلیٹڈ دنیا کبھی بھی حقیقت کی کامل نمائندگی نہیں ہوتی۔ سیمولیشن اور حقیقی دنیا کے درمیان فرق - طبیعیات، سینسر شور، اور ایکچویٹر ردعمل کے لحاظ سے - "سم-ٹو-ریئل" گیپ کے نام سے جانا جاتا ہے۔ جدید روبوٹکس تحقیق کا ایک کلیدی شعبہ اس گیپ کو پر کرنے کے لیے تکنیک (جیسے ڈومین رینڈمائزیشن، جس پر ہم نے باب 4 میں بحث کی تھی) تیار کر رہا ہے، تاکہ یہ یقینی بنایا جا سکے کہ جو کچھ سیمولیشن میں کام کرتا ہے وہ حقیقی روبوٹ پر بھی کام کرے۔

### 6.2.2 روبوٹکس سیمولیشن پلیٹ فارمز
روبوٹسٹس کے لیے کئی طاقتور سیمولیشن ٹولز دستیاب ہیں، ہر ایک کی اپنی طاقتیں ہیں۔

- **گیزیبو (Gazebo)**: ایک مقبول، اوپن سورس 3D روبوٹکس سمیلیٹر۔ یہ حقیقت پسندانہ طبیعیات سیمولیشن (بشمول متعدد فزکس انجن جیسے ODE اور DART) اور سینسر ماڈلز کی ایک وسیع رینج پیش کرتا ہے۔ گیزیبو ROS کے ساتھ مضبوطی سے مربوط ہے، جو اسے ROS کمیونٹی کے لیے ایک معیاری انتخاب بناتا ہے۔
- **پائ بلٹ (PyBullet)**: ایک Python پر مبنی فزکس انجن جو بہت تیز اور استعمال میں آسان ہے۔ اگرچہ اس میں گیزیبو کی طرح سینسر کی وفاداری کی سطح نہیں ہو سکتی ہے، لیکن اس کی سادگی اور رفتار اسے تعلیم، پروٹوٹائپنگ، اور کمک سیکھنے کی تحقیق کے لیے ایک بہترین ٹول بناتی ہے۔
- **این ویڈیا آئزک سم (NVIDIA Isaac Sim)**: ایک جدید، فوٹو ریئلسٹک روبوٹکس سمیلیٹر جو NVIDIA Omniverse پلیٹ فارم پر بنایا گیا ہے۔ اس کا کلیدی فائدہ اس کی اعلیٰ وفاداری والی رینڈرنگ اور فزکس ہے، جو GPU سے تیز ہوتی ہے۔ یہ اسے ادراک الگورتھم (جیسے کمپیوٹر ویژن ماڈلز) کی تربیت اور جانچ کے لیے مثالی بناتا ہے جو حقیقت پسندانہ سینسر ڈیٹا پر انحصار کرتے ہیں۔
- **میوجوکو (MuJoCo - ملٹی جوائنٹ ڈائنامکس ود کانٹیکٹ)**: ایک فزکس انجن جو پیچیدہ رابطہ حرکیات کو سمیلیٹ کرنے میں اپنی غیر معمولی رفتار اور درستگی کے لیے جانا جاتا ہے۔ یہ حرکت اور ہیرا پھیری کی پالیسیوں کی تربیت کے لیے کمک سیکھنے والی کمیونٹی میں ایک پسندیدہ بن گیا ہے۔

### 6.2.3 روبوٹ آپریٹنگ سسٹم (ROS)
ROS ونڈوز یا لینکس جیسا روایتی آپریٹنگ سسٹم نہیں ہے۔ بلکہ، یہ روبوٹ سافٹ ویئر لکھنے کے لیے ایک لچکدار فریم ورک ہے۔ یہ ٹولز، لائبریریوں، اور کنونشنز کا ایک مجموعہ فراہم کرتا ہے جس کا مقصد پیچیدہ اور مضبوط روبوٹ رویے کو بنانے کے کام کو آسان بنانا ہے۔

- **بنیادی تصورات**: ROS ایک "پبلش/سبسکرائب" میسجنگ ماڈل پر بنایا گیا ہے۔
    - **نوڈز (Nodes)**: ایک نوڈ ایک قابل عمل پروگرام ہے (جیسے، ایک کیمرہ ڈرائیور، ایک پاتھ پلانر)۔ ایک ROS نظام کئی نوڈز پر مشتمل ہوتا ہے۔
    - **ٹاپکس (Topics)**: نوڈز ایک دوسرے سے "ٹاپکس" پر پیغامات شائع کرکے بات چیت کرتے ہیں۔ مثال کے طور پر، ایک کیمرہ نوڈ `/camera/image` ٹاپک پر تصویری ڈیٹا شائع کر سکتا ہے۔
    - **پیغامات (Messages)**: ڈیٹا پیغامات کے ذریعے بھیجا جاتا ہے، جن کی ایک متعین ساخت ہوتی ہے۔ مثال کے طور پر، ایک `Image` پیغام میں اونچائی، چوڑائی، اور تصویری ڈیٹا کے لیے فیلڈز ہوتے ہیں۔
    - **سروسز اور ایکشنز**: مسلسل ڈیٹا اسٹریمز کے لیے پبلش/سبسکرائب ماڈل کے علاوہ، ROS میں درخواست/جواب کے تعاملات کے لیے "سروسز" اور طویل عرصے تک چلنے والے، فیڈ بیک پر مبنی کاموں کے لیے "ایکشنز" بھی ہیں۔
- **ROS کیوں استعمال کریں؟**:
    - **ماڈیولریٹی**: یہ ایک پیچیدہ نظام کو چھوٹے، قابل انتظام نوڈز میں توڑنے کی اجازت دیتا ہے۔
    - **کوڈ کا دوبارہ استعمال**: ROS کمیونٹی بہت وسیع ہے، اور ہارڈویئر ڈرائیورز سے لے کر جدید ترین SLAM الگورتھمز تک ہر چیز کے لیے ہزاروں عوامی طور پر دستیاب پیکجز موجود ہیں۔ یہ ڈویلپرز کو "پہیے کو دوبارہ ایجاد کرنے" سے بچنے کی اجازت دیتا ہے۔

## 6.3 عملی اطلاقات اور کیس اسٹڈیز

### 6.3.1 کیس اسٹڈی: ایجیلٹی روبوٹکس کے ڈیجٹ کے ساتھ گودام آٹومیشن
- **مسئلہ**: اگرچہ گودام تیزی سے خودکار ہو رہے ہیں، لاجسٹکس کے "آخری 100 فٹ" - ٹرکوں کو اتارنا، ٹوٹس کو ایک کنویئر سے دوسرے میں منتقل کرنا - اب بھی اکثر انسانی محنت کی ضرورت ہوتی ہے کیونکہ جگہیں انسانوں کے لیے ڈیزائن کی گئی ہیں۔
- **حل**: ڈیجٹ ایک دوپایہ روبوٹ ہے جسے انسانی جگہوں پر کام کرنے کے لیے ڈیزائن کیا گیا ہے۔ یہ چل سکتا ہے، سیڑھیاں چڑھ سکتا ہے، اور تنگ کونوں میں نیویگیٹ کر سکتا ہے۔ اس کے بلٹ ان بازو اسے معیاری گودام ٹوٹس کو اٹھانے اور رکھنے کی اجازت دیتے ہیں۔
- **ٹیکنالوجی**: ڈیجٹ جدید روبوٹکس کی مثال ہے۔ اس کے کنٹرول الگورتھم کو حقیقی روبوٹ پر تعینات کرنے سے پہلے سیمولیشن میں بہت زیادہ تیار اور جانچا جاتا ہے۔ یہ اپنے ماحول میں نیویگیٹ کرنے کے لیے LiDAR اور کیمروں کے امتزاج کا استعمال کرتا ہے، اور اسے ایک "پلیٹ فارم" کے طور پر ڈیزائن کیا گیا ہے جسے گاہک اپنے موجودہ لاجسٹکس سافٹ ویئر میں ضم کر سکتے ہیں۔

### 6.3.2 کیس اسٹڈی: ناسا کی ویلکیری کے ساتھ آفات کا جواب
- **مسئلہ**: ایٹمی تباہی جیسی آفت کے بعد، انسانی پہلے جواب دہندگان کو بھیجنا بہت خطرناک ہے۔ ایک ایسے روبوٹ کی ضرورت ہے جو انسانی ماحول میں کام کر سکے اور اہم کام انجام دینے کے لیے انسانی اوزار استعمال کر سکے (جیسے، والوز کو گھمانا، ملبہ صاف کرنا)۔
- **حل**: ناسا کی ویلکیری دنیا کے سب سے جدید ہیومنائڈ روبوٹس میں سے ایک ہے، جسے بالکل اسی مقصد کے لیے ڈیزائن کیا گیا ہے۔ اس میں بہت زیادہ ڈگری آف فریڈم، طاقتور ایکچویٹرز، اور ایک جدید سینسر سوٹ ہے۔
- **ٹیکنالوجی**: ویلکیری کے جوڑ سیریز الاسٹک ایکچویators (SEAs) کا استعمال کرتے ہیں، جو عین مطابق فورس کنٹرول اور تعمیل کی اجازت دیتے ہیں۔ اس کا ادراک نظام متعدد کیمروں، LiDAR، اور دیگر سینسرز سے ڈیٹا کو فیوز کرتا ہے۔ کاموں کی پیچیدگی کی وجہ سے، ویلکیری کو اکثر زیر نگرانی خود مختاری کے ذریعے کنٹرول کیا جاتا ہے، جہاں ایک انسانی آپریٹر اعلیٰ سطحی کمانڈ فراہم کرتا ہے، اور روبوٹ نچلی سطح کی حرکات کو خود مختار طور پر انجام دیتا ہے۔

## 6.4 عملی مشقیں

### مشق 6.1: صحیح سمیلیٹر کا انتخاب
مندرجہ ذیل ہر روبوٹکس پروجیکٹ کے لیے، زیر بحث سمیلیٹرز (گیزیبو، پائ بلٹ، آئزک سم) میں سے سب سے موزوں کا انتخاب کریں۔ اپنے انتخاب کا جواز پروجیکٹ کے بنیادی ہدف اور سمیلیٹر کی طاقتوں پر غور کرکے پیش کریں۔
1. ایک یونیورسٹی کے طالب علم کا آخری سال کا پروجیکٹ ایک سادہ 3 جوڑوں والے روبوٹک بازو کی تعمیر اور جانچ کے لیے۔
2. ایک خود چلانے والی کار کمپنی جسے اپنے ادراک نظام کی مختلف موسم اور روشنی کے حالات میں پیدل چلنے والوں کی شناخت کرنے کی صلاحیت کو جانچنے کی ضرورت ہے۔
3. ایک تحقیقی لیب جو کمک سیکھنے کا استعمال کرتے ہوئے ایک دوپایہ روبوٹ کو چلنا سکھانے کے لیے ہزاروں متوازی تجربات کو جلد از جلد چلانا چاہتی ہے۔

### مشق 6.2: ایک ROS نظام کو ڈی کنسٹرکٹ کرنا
ایک ROS- فعال روبوٹ، جیسے ٹرٹل بوٹ، کو ایک کمرے میں نیویگیٹ کرتے ہوئے ایک ویڈیو دیکھیں۔ جو آپ دیکھتے ہیں اس کی بنیاد پر، اس کے ROS فن تعمیر کا ایک سادہ خاکہ بنانے کی کوشش کریں۔
1. کم از کم تین ممکنہ **نوڈز** کی شناخت کریں (جیسے، `/lidar_driver`, `/path_planner`, `/motor_controller`)۔
2. ہر نوڈ کے لیے، کم از کم ایک **ٹاپک** کی شناخت کریں جس پر وہ شائع یا سبسکرائب کر سکتا ہے اور اس **پیغام** کی قسم جو وہ بھیج سکتا ہے (جیسے، `/lidar_driver` نوڈ `/scan` ٹاپک پر ایک `LaserScan` پیغام شائع کرتا ہے)۔

## 6.5 پروگرامنگ لیب

### 6.5.1 ماحول کو ترتیب دینا
ہمیشہ کی طرح، یقینی بنائیں کہ آپ کے پاس Python اور `pybullet` انسٹال ہیں۔

### 6.5.2 کوڈ کا ٹکڑا: ایک سمیلیٹڈ روبوٹ کے ساتھ تعامل
یہ لیب ظاہر کرتی ہے کہ آپ کے سمیلیٹڈ روبوٹ کے ایک حصے کو حقیقی وقت میں کنٹرول کرنے کے لیے ایک سادہ گرافیکل یوزر انٹرفیس (GUI) عنصر کیسے بنایا جائے۔ یہ ٹیلی آپریشن کی ایک بنیادی شکل ہے اور ایک بدیہی احساس فراہم کرتی ہے کہ کنٹرول ان پٹس روبوٹ کی حالت کو کیسے متاثر کرتے ہیں۔

```python
import pybullet as p
import pybullet_data
import time

# Set up the simulation environment
p.connect(p.GUI)
p.setAdditionalSearchPath(pybullet_data.getDataPath())
p.setGravity(0, 0, -9.81)
p.loadURDF("plane.urdf")

# Load a simple robot with some joints, like the KUKA arm
robotId = p.loadURDF("kuka_lbr_iiwa/model.urdf", [0, 0, 0])

# Get the number of joints
num_joints = p.getNumJoints(robotId)

# --- Create a GUI Slider to Control a Joint ---
# We will control the first joint. First, get its limits.
joint_info = p.getJointInfo(robotId, 0)
joint_lower_limit = joint_info[8]
joint_upper_limit = joint_info[9]

# Create a slider in the PyBullet GUI
# The slider will allow us to interactively change the target angle for joint 0
joint_slider_id = p.addUserDebugParameter(
    paramName="Joint 0 Angle",
    rangeMin=joint_lower_limit,
    rangeMax=joint_upper_limit,
    startValue=0
)

# --- Simulation Loop ---
while True:
    try:
        # Read the current value from the GUI slider
        target_angle = p.readUserDebugParameter(joint_slider_id)
        
        # Set the target position for the first joint
        p.setJointMotorControl2(
            bodyUniqueId=robotId,
            jointIndex=0,
            controlMode=p.POSITION_CONTROL,
            targetPosition=target_angle
        )
        
        # Step the simulation
        p.stepSimulation()
        time.sleep(1./240.)
        
    except p.error:
        # This will catch the error when the user closes the GUI window
        break

print("Simulation finished.")
p.disconnect()
```
**وضاحت:**
- `p.addUserDebugParameter()`: یہ فنکشن GUI ونڈو میں ایک سلائیڈر بناتا ہے۔ ہم اسے ایک نام، ایک کم سے کم/زیادہ سے زیادہ رینج (جو ہم روبوٹ کی اصل جوڑوں کی حدود سے حاصل کرتے ہیں)، اور ایک ابتدائی قدر دیتے ہیں۔
- `p.readUserDebugParameter()`: سیمولیشن لوپ کے اندر، ہم مسلسل سلائیڈر کی موجودہ قدر پڑھتے ہیں۔
- `p.setJointMotorControl2()`: پھر ہم اس قدر کو اپنے جوائنٹ کنٹرولر کے لیے `targetPosition` کے طور پر استعمال کرتے ہیں۔
- نتیجہ یہ ہے کہ جیسے ہی آپ GUI میں سلائیڈر کو حرکت دیتے ہیں، روبوٹ کا پہلا جوڑ سیمولیشن میں حقیقی وقت میں حرکت کرے گا، جو آپ کو روبوٹ کو کنٹرول کرنے کا ایک براہ راست، انٹرایکٹو طریقہ فراہم کرتا ہے۔

## 6.6 باب کا خلاصہ
اس باب نے ان ٹولز اور پلیٹ فارمز کا ایک عملی جائزہ فراہم کیا جو روبوٹکس کے تصورات کو زندہ کرتے ہیں۔ ہم نے سیکھا کہ سیمولیشن جدید روبوٹکس کی ترقی کا ایک سنگ بنیاد ہے، جو محفوظ، تیز، اور لاگت سے موثر جانچ کو ممکن بناتی ہے، جس میں "سم-ٹو-ریئل" گیپ ایک کلیدی چیلنج ہے۔ ہم نے بڑے سیمولیشن پلیٹ فارمز جیسے گیزیبو، پائ بلٹ، اور آئزک سم کا سروے کیا، ہر ایک کی منفرد طاقتوں کے ساتھ۔ ہم نے روبوٹ آپریٹنگ سسٹم (ROS) کو بھی ماڈیولر اور دوبارہ قابل استعمال روبوٹ سافٹ ویئر بنانے کے لیے معیاری فریم ورک کے طور پر متعارف کرایا۔ آخر میں، ڈیجٹ اور ویلکیری کی کیس اسٹڈیز نے ظاہر کیا کہ یہ ٹولز اور جدید ہارڈویئر پیچیدہ، حقیقی دنیا کے مسائل کو حل کرنے کے لیے کس طرح مربوط کیے جا رہے ہیں۔ یہ باب آپ کو یہ سمجھنے کے لیے سیاق و سباق سے لیس کرتا ہے کہ پچھلے ابواب کے نظریاتی تصورات کو عملی جامہ کیسے پہنایا جاتا ہے۔

## 6.7 مزید مطالعہ
-   **ROS وکی**: سرکاری دستاویزات اور ٹیوٹوریلز ROS سیکھنے کے لیے بہترین جگہ ہیں۔ (wiki.ros.org)
-   **گیزیبو سمیلیٹر ویب سائٹ**: (gazebosim.org)
-   **پائ بلٹ دستاویزات**: کوئک اسٹارٹ گائیڈ اور مثالیں شامل ہیں۔ (pybullet.org)
-   **این ویڈیا آئزک سم ویب سائٹ**: (developer.nvidia.com/isaac-sim)
